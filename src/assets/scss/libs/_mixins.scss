@use 'sass:math';
@use 'vars' as *;

/// Wraps @content in a @media block using a given breakpoint.
@mixin breakpoint($breakpoint) {
    @if $breakpoint == 'xlarge' {
        @media screen and #{$breakpoint-xlarge} { @content; }
    }
    @else if $breakpoint == 'large' {
        @media screen and #{$breakpoint-large} { @content; }
    }
    @else if $breakpoint == 'medium' {
        @media screen and #{$breakpoint-medium} { @content; }
    }
    @else if $breakpoint == 'small' {
        @media screen and #{$breakpoint-small} { @content; }
    }
    @else if $breakpoint == 'xsmall' {
        @media screen and #{$breakpoint-xsmall} { @content; }
    }
    @else if $breakpoint == 'xxsmall' {
        @media screen and #{$breakpoint-xxsmall} { @content; }
    }
}

/// Makes an element's :before pseudoelement a FontAwesome icon.
/// @param {string} $content Optional content value to use.
/// @param {string} $category Optional category (regular, solid, brands).
/// @param {string} $where Optional pseudoelement to target (before or after).
@mixin icon($content: false, $category: regular, $where: before) {
    text-decoration: none;

    &:#{$where} {
        @if $content {
            content: $content;
        }

        -moz-osx-font-smoothing: grayscale;
        -webkit-font-smoothing: antialiased;
        display: inline-block;
        font-style: normal;
        font-variant: normal;
        text-rendering: auto;
        line-height: 1;
        text-transform: none !important;

        @if $category == brands {
            font-family: 'Font Awesome 5 Brands';
        }
        @else if $category == solid {
            font-family: 'Font Awesome 5 Free';
            font-weight: 900;
        }
        @else {
            font-family: 'Font Awesome 5 Free';
            font-weight: 400;
        }
    }
}

/// Applies padding to an element, taking the current element-margin value into account.
/// @param {mixed} $tb Top/bottom padding.
/// @param {mixed} $lr Left/right padding.
/// @param {list} $pad Optional extra padding (in the following order top, right, bottom, left)
/// @param {bool} $important If true, adds !important.
@mixin padding($tb, $lr, $pad: (0,0,0,0), $important: null) {
    $x: 0.1em;

    @if unit($size-element-margin) == 'rem' {
        $x: 0.1rem;
    }

    padding: ($tb + nth($pad,1)) ($lr + nth($pad,2)) max($x, $tb - $size-element-margin + nth($pad,3)) ($lr + nth($pad,4)) #{$important};
}

/// Helper function for flexgrid.
@function get-flexgrid-margins($columns, $gutters) {
    $margins: math.div($gutters, ($columns - 1));
    @return $margins;
}

/// Sets up flexgrid columns.
/// @param {integer} $columns Columns.
/// @param {number} $gutters Gutters.
/// @param {mixed} $align Optional, alignment (defaults to null - full width).
@mixin flexgrid-columns($columns, $gutters, $align: null) {
    > * {
        $cell-width: math.div(100%, $columns);
        $cell-width-pad: ($gutters * math.div($columns - 1, $columns));

        width: if($align == null, calc(#{$cell-width} - #{$cell-width-pad}), $align);
        margin-left: $gutters;
    }
}

/// Initializes base flexgrid classes.
/// @param {string} $vertical-align Vertical alignment of cells.
/// @param {string} $horizontal-align Horizontal alignment of cells.
@mixin flexgrid-base($vertical-align: null, $horizontal-align: null) {
    display: flex;
    flex-wrap: wrap;

    @if $vertical-align != null {
        align-items: $vertical-align;
    }

    @if $horizontal-align != null {
        justify-content: $horizontal-align;
    }
}